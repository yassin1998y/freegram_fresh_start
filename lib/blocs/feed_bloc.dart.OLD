// lib/blocs/feed_bloc.dart

import 'dart:async';

import 'package:bloc/bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/foundation.dart';
import 'package:freegram/models/post_model.dart';
import 'package:freegram/models/ad_placeholder.dart';
import 'package:freegram/repositories/post_repository.dart';
import 'package:freegram/repositories/user_repository.dart';
import 'package:freegram/repositories/page_repository.dart';
import 'package:freegram/utils/enums.dart';

// Events
abstract class FeedEvent extends Equatable {
  const FeedEvent();

  @override
  List<Object?> get props => [];
}

class LoadFeedEvent extends FeedEvent {
  final bool refresh;
  final TimeFilter timeFilter;

  const LoadFeedEvent({
    this.refresh = false,
    this.timeFilter = TimeFilter.allTime,
  });

  @override
  List<Object?> get props => [refresh, timeFilter];
}

class LoadMoreFeedEvent extends FeedEvent {
  const LoadMoreFeedEvent();
}

class StartFeedStreamEvent extends FeedEvent {
  const StartFeedStreamEvent();
}

class StopFeedStreamEvent extends FeedEvent {
  const StopFeedStreamEvent();
}

// States
abstract class FeedState extends Equatable {
  const FeedState();

  @override
  List<Object?> get props => [];
}

class FeedInitial extends FeedState {
  const FeedInitial();
}

class FeedLoading extends FeedState {
  const FeedLoading();
}

class FeedLoaded extends FeedState {
  final List<Object> feedItems; // Mixed: PostModel and AdPlaceholder
  final bool hasMore;
  final bool isLoadingMore;
  final TimeFilter timeFilter;

  const FeedLoaded({
    required this.feedItems,
    this.hasMore = true,
    this.isLoadingMore = false,
    this.timeFilter = TimeFilter.allTime,
  });

  FeedLoaded copyWith({
    List<Object>? feedItems,
    bool? hasMore,
    bool? isLoadingMore,
    TimeFilter? timeFilter,
  }) {
    return FeedLoaded(
      feedItems: feedItems ?? this.feedItems,
      hasMore: hasMore ?? this.hasMore,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      timeFilter: timeFilter ?? this.timeFilter,
    );
  }

  /// Helper getter to extract only posts (for backward compatibility if needed)
  List<PostModel> get posts {
    return feedItems.whereType<PostModel>().toList();
  }

  @override
  List<Object?> get props => [feedItems, hasMore, isLoadingMore, timeFilter];
}

class FeedError extends FeedState {
  final String message;

  const FeedError(this.message);

  @override
  List<Object?> get props => [message];
}

// BLoC
class FeedBloc extends Bloc<FeedEvent, FeedState> {
  final PostRepository _postRepository;
  final UserRepository? _userRepository; // Optional for getting user targeting
  final PageRepository? _pageRepository; // For getting followed pages
  final String _userId;
  final FeedType _feedType;
  DocumentSnapshot? _lastDocument;
  DocumentSnapshot? _lastBoostedDocument;
  bool _hasMore = true;
  StreamSubscription<List<PostModel>>? _feedStreamSubscription;

  // Ad placement configuration
  static const int _adFrequency = 5; // Insert ad every N posts
  static const int _minPostsBeforeFirstAd =
      3; // Don't show ads in first N posts
  int _adCounter = 0; // Track total items (posts + ads) for positioning

  FeedBloc({
    required PostRepository postRepository,
    required String userId,
    FeedType feedType = FeedType.following,
    UserRepository? userRepository,
    PageRepository? pageRepository,
  })  : _postRepository = postRepository,
        _userRepository = userRepository,
        _pageRepository = pageRepository,
        _userId = userId,
        _feedType = feedType,
        super(const FeedInitial()) {
    on<LoadFeedEvent>(_onLoadFeed);
    on<LoadMoreFeedEvent>(_onLoadMoreFeed);
    on<StartFeedStreamEvent>(_onStartFeedStream);
    on<StopFeedStreamEvent>(_onStopFeedStream);
  }

  @override
  Future<void> close() {
    _feedStreamSubscription?.cancel();
    return super.close();
  }

  Future<void> _onLoadFeed(LoadFeedEvent event, Emitter<FeedState> emit) async {
    if (event.refresh) {
      _lastDocument = null;
      _hasMore = true;
    }

    emit(const FeedLoading());

    try {
      List<PostModel> posts;
      DocumentSnapshot? lastDoc;

      switch (_feedType) {
        case FeedType.following:
          // Get regular feed
          final result = await _postRepository.getFeedForUserWithPagination(
            userId: _userId,
            lastDocument: _lastDocument,
            limit: 10,
          );
          posts = result.$1;
          lastDoc = result.$2;

          // Also get posts from followed pages and mix them in
          if (_pageRepository != null) {
            try {
              final pagePosts = await _pageRepository.getPageFeed(
                userId: _userId,
                limit: 5, // Get fewer page posts to mix in
              );
              // Mix page posts into regular feed
              posts = _mixPagePosts(posts, pagePosts);
            } catch (e) {
              debugPrint('FeedBloc: Error getting page feed: $e');
              // Continue with regular posts only
            }
          }
          break;

        case FeedType.trending:
          posts = await _postRepository.getTrendingPosts(
            timeFilter: event.timeFilter,
            lastDocument: _lastDocument,
            limit: 10,
          );
          lastDoc = posts.isNotEmpty && posts.length == 10
              ? await _getLastDocumentFromPosts(posts)
              : null;
          break;

        case FeedType.nearby:
          // For now, use following feed - nearby can be implemented later
          final result = await _postRepository.getFeedForUserWithPagination(
            userId: _userId,
            lastDocument: _lastDocument,
            limit: 10,
          );
          posts = result.$1;
          lastDoc = result.$2;
          break;
      }

      _lastDocument = lastDoc;
      _hasMore = posts.length == 10; // Assuming limit is 10

      // Reset ad counter on refresh
      if (event.refresh) {
        _adCounter = 0;
      }

      // Fetch boosted posts and mix them in
      final boostedPosts = await _getBoostedPosts();

      // Mix boosted posts into regular feed (1 boosted per 10 regular posts)
      final mixedPosts = _mixBoostedPosts(posts, boostedPosts);

      // Insert ad placeholders into feed
      final mixedItems = _insertAdPlaceholders(mixedPosts);

      emit(FeedLoaded(
        feedItems: mixedItems,
        hasMore: _hasMore,
        timeFilter: event.timeFilter,
      ));
    } catch (e) {
      debugPrint('FeedBloc: Error loading feed: $e');
      emit(FeedError(e.toString()));
    }
  }

  /// Helper method to get the last document snapshot from posts
  /// This is needed for trending posts since getTrendingPosts doesn't return a tuple
  Future<DocumentSnapshot?> _getLastDocumentFromPosts(
      List<PostModel> posts) async {
    if (posts.isEmpty) return null;
    try {
      final lastPost = posts.last;
      return await FirebaseFirestore.instance
          .collection('posts')
          .doc(lastPost.id)
          .get();
    } catch (e) {
      debugPrint('FeedBloc: Error getting last document: $e');
      return null;
    }
  }

  Future<void> _onLoadMoreFeed(
      LoadMoreFeedEvent event, Emitter<FeedState> emit) async {
    if (state is FeedLoaded) {
      final currentState = state as FeedLoaded;
      if (!currentState.hasMore || currentState.isLoadingMore) return;

      emit(currentState.copyWith(isLoadingMore: true));

      try {
        List<PostModel> morePosts;
        DocumentSnapshot? lastDoc;

        switch (_feedType) {
          case FeedType.following:
            final result = await _postRepository.getFeedForUserWithPagination(
              userId: _userId,
              lastDocument: _lastDocument,
              limit: 10,
            );
            morePosts = result.$1;
            lastDoc = result.$2;
            break;

          case FeedType.trending:
            morePosts = await _postRepository.getTrendingPosts(
              timeFilter: currentState.timeFilter,
              lastDocument: _lastDocument,
              limit: 10,
            );
            lastDoc = morePosts.isNotEmpty && morePosts.length == 10
                ? await _getLastDocumentFromPosts(morePosts)
                : null;
            break;

          case FeedType.nearby:
            // For now, use following feed - nearby can be implemented later
            final result = await _postRepository.getFeedForUserWithPagination(
              userId: _userId,
              lastDocument: _lastDocument,
              limit: 10,
            );
            morePosts = result.$1;
            lastDoc = result.$2;
            break;
        }

        _lastDocument = lastDoc;
        _hasMore = morePosts.length == 10;

        // Insert ad placeholders into new posts
        final mixedMoreItems = _insertAdPlaceholders(morePosts,
            startIndex: currentState.feedItems.length);

        // Combine existing feed items with new mixed items
        final updatedItems = [...currentState.feedItems, ...mixedMoreItems];

        emit(FeedLoaded(
          feedItems: updatedItems,
          hasMore: _hasMore,
          isLoadingMore: false,
          timeFilter: currentState.timeFilter,
        ));
      } catch (e) {
        debugPrint('FeedBloc: Error loading more feed: $e');
        emit(FeedError(e.toString()));
      }
    }
  }

  void _onStartFeedStream(StartFeedStreamEvent event, Emitter<FeedState> emit) {
    // Cancel existing subscription if any
    _feedStreamSubscription?.cancel();

    // Subscribe to real-time feed stream
    _feedStreamSubscription = _postRepository.getFeedStream(_userId).listen(
      (streamPosts) {
        // Merge with existing posts if in FeedLoaded state
        if (state is FeedLoaded) {
          final currentState = state as FeedLoaded;

          // Update existing posts with stream data (for reaction/comment counts)
          final updatedPosts = currentState.posts.map((existingPost) {
            final streamPost = streamPosts.firstWhere(
              (p) => p.id == existingPost.id,
              orElse: () => existingPost,
            );
            // Only update if it's actually different
            if (streamPost.id == existingPost.id &&
                (streamPost.reactionCount != existingPost.reactionCount ||
                    streamPost.commentCount != existingPost.commentCount)) {
              return existingPost.copyWith(
                reactionCount: streamPost.reactionCount,
                commentCount: streamPost.commentCount,
                trendingScore: streamPost.trendingScore,
                lastEngagementTimestamp: streamPost.lastEngagementTimestamp,
              );
            }
            return existingPost;
          }).toList();

          // Add new posts from stream that don't exist yet
          final existingIds = currentState.posts.map((p) => p.id).toSet();
          final newPosts =
              streamPosts.where((p) => !existingIds.contains(p.id)).toList();

          // Merge: existing updated posts + new posts, maintaining order
          final mergedPosts = [...updatedPosts, ...newPosts];

          // Convert merged posts to feed items (no ads in stream updates for simplicity)
          final mergedFeedItems = mergedPosts.cast<Object>().toList();

          // Emit updated state with merged feed items
          emit(FeedLoaded(
            feedItems: mergedFeedItems,
            hasMore: currentState.hasMore,
            isLoadingMore: currentState.isLoadingMore,
            timeFilter: currentState.timeFilter,
          ));
        } else {
          // If not loaded yet, just emit the stream posts as feed items
          emit(FeedLoaded(
            feedItems: streamPosts.cast<Object>().toList(),
            hasMore: true,
            timeFilter: TimeFilter.allTime,
          ));
        }
      },
      onError: (error) {
        debugPrint('FeedBloc: Error in feed stream: $error');
        // Don't override current state with error if we have posts loaded
        if (state is! FeedLoaded) {
          emit(FeedError(error.toString()));
        }
      },
    );
  }

  void _onStopFeedStream(StopFeedStreamEvent event, Emitter<FeedState> emit) {
    _feedStreamSubscription?.cancel();
    _feedStreamSubscription = null;
  }

  /// Get boosted posts with user targeting
  Future<List<PostModel>> _getBoostedPosts() async {
    try {
      // Build user targeting map
      Map<String, dynamic> userTargeting = {};

      if (_userRepository != null) {
        try {
          final user = await _userRepository.getUser(_userId);
          userTargeting = {
            'age': user.age,
            'gender': user.gender,
            'interests': user.interests,
            // Note: Location can be added if available
          };
        } catch (e) {
          debugPrint('FeedBloc: Error getting user for targeting: $e');
          // Continue with empty targeting
        }
      }

      final boostedPosts = await _postRepository.getBoostedPosts(
        userTargeting: userTargeting,
        lastDocument: _lastBoostedDocument,
        limit: 10,
      );

      if (boostedPosts.isNotEmpty) {
        // Update last boosted document for pagination
        // Note: We'd need to store the last doc from getBoostedPosts
        // For simplicity, we'll fetch fresh boosted posts each time
      }

      return boostedPosts;
    } catch (e) {
      debugPrint('FeedBloc: Error getting boosted posts: $e');
      return []; // Return empty list on error
    }
  }

  /// Mix page posts into regular posts
  List<PostModel> _mixPagePosts(
    List<PostModel> regularPosts,
    List<PostModel> pagePosts,
  ) {
    if (pagePosts.isEmpty) return regularPosts;

    final mixed = <PostModel>[];
    final pageIterator = pagePosts.iterator;
    bool hasMorePages = pageIterator.moveNext();

    for (int i = 0; i < regularPosts.length; i++) {
      mixed.add(regularPosts[i]);

      // Insert page post every 5 regular posts
      if (hasMorePages && (i + 1) % 5 == 0) {
        mixed.add(pageIterator.current);
        hasMorePages = pageIterator.moveNext();
      }
    }

    // Add remaining page posts at the end
    while (hasMorePages) {
      mixed.add(pageIterator.current);
      hasMorePages = pageIterator.moveNext();
    }

    return mixed;
  }

  /// Mix boosted posts into regular posts (1 boosted per 10 regular)
  List<PostModel> _mixBoostedPosts(
    List<PostModel> regularPosts,
    List<PostModel> boostedPosts,
  ) {
    if (boostedPosts.isEmpty) return regularPosts;

    final mixed = <PostModel>[];
    final boostedIterator = boostedPosts.iterator;
    bool hasMoreBoosted = boostedIterator.moveNext();

    for (int i = 0; i < regularPosts.length; i++) {
      mixed.add(regularPosts[i]);

      // Insert boosted post every 10 regular posts
      if (hasMoreBoosted && (i + 1) % 10 == 0) {
        mixed.add(boostedIterator.current);
        hasMoreBoosted = boostedIterator.moveNext();
      }
    }

    return mixed;
  }

  /// Insert ad placeholders into the posts list based on frequency
  /// Returns a mixed list of PostModel and AdPlaceholder objects
  List<Object> _insertAdPlaceholders(
    List<PostModel> posts, {
    int startIndex = 0,
  }) {
    final List<Object> mixedItems = [];

    for (int i = 0; i < posts.length; i++) {
      final post = posts[i];
      final absoluteIndex = startIndex + i;

      // Add the post
      mixedItems.add(post);
      _adCounter++;

      // Insert ad placeholder after every N posts, but not in first few posts
      if (absoluteIndex >= _minPostsBeforeFirstAd &&
          _adCounter % _adFrequency == 0) {
        mixedItems.add(AdPlaceholder(
          id: 'ad_${DateTime.now().millisecondsSinceEpoch}_$absoluteIndex',
          position: absoluteIndex,
        ));
        _adCounter++; // Increment counter for ad
      }
    }

    return mixedItems;
  }
}
