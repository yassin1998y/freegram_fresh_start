<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Freegram Bot Client</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: monospace;
            background: #222;
            color: #0f0;
        }

        #log {
            white-space: pre-wrap;
        }

        video {
            width: 300px;
            height: 200px;
            background: #000;
            border: 1px solid #444;
        }
    </style>
</head>

<body>
    <h1>Freegram Bot (<span id="botId">Unknown</span>)</h1>
    <div>
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>
    <div id="log"></div>

    <script>
        const SIGNALING_URL = 'https://freegram-signaling-60183775527.us-central1.run.app'; // Production

        // Parse URL Params
        const urlParams = new URLSearchParams(window.location.search);
        const PERSONA = urlParams.get('persona') || 'NORMAL';
        const ID_PARAM = urlParams.get('id') || Math.floor(Math.random() * 1000);

        const botId = `bot_${ID_PARAM}_${PERSONA}`;
        document.getElementById('botId').innerText = botId;

        let socket;
        let peerConnection;
        let dataChannel;
        let localStream;
        let roomId;
        let currentPartnerId;

        // Stats
        let messagesSent = 0;
        let errors = 0;

        const config = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        function log(msg) {
            const el = document.getElementById('log');
            // send to console for puppeteer to pick up with tag
            console.log(`[Bot] ${msg}`);
            el.innerText = `[${new Date().toLocaleTimeString()}] ${msg}\n` + el.innerText.substring(0, 1000);
        }

        async function start() {
            log(`Starting Client as ${PERSONA}...`);

            // Get Fake Media
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                document.getElementById('localVideo').srcObject = localStream;
                log('Got local stream (fake)');
            } catch (e) {
                log('Error getting media: ' + e);
                return;
            }

            connectSocket();
        }

        function connectSocket() {
            socket = io(SIGNALING_URL, {
                transports: ['websocket', 'polling'], // Match Flutter config
                reconnection: true
            });

            socket.on('connect', () => {
                log('Socket Connected: ' + socket.id);
                findMatch();
            });

            socket.on('disconnect', () => {
                log('Socket Disconnected');
            });

            socket.on('waiting_for_match', () => {
                log('Waiting for match...');
            });

            socket.on('match_found', async (data) => {
                log(`Match Found! Room: ${data.roomId}, Role: ${data.role}`);
                roomId = data.roomId;
                currentPartnerId = data.partnerId;

                createPeerConnection();

                if (data.role === 'offer') {
                    // Create Data Channel (Caller moves first)
                    createDataChannel();

                    // Create Offer
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    socket.emit('offer', {
                        roomId: roomId,
                        offer: { sdp: offer.sdp, type: offer.type }
                    });
                    log('Sent Offer');
                }
            });

            socket.on('offer', async (data) => {
                log('Received Offer');
                if (!peerConnection) createPeerConnection();

                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                socket.emit('answer', {
                    roomId: roomId,
                    answer: { sdp: answer.sdp, type: answer.type }
                });
                log('Sent Answer');
            });

            socket.on('answer', async (data) => {
                log('Received Answer');
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            });

            socket.on('candidate', async (data) => {
                // log('Received Candidate'); 
                if (peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            });

            socket.on('peer_disconnected', () => {
                log('Peer Disconnected. Restarting...');
                closeCall();
                setTimeout(findMatch, 2000); // Wait a bit
            });
        }

        function findMatch() {
            log('Emitting find_random_match...');
            socket.emit('find_random_match');
        }

        function createPeerConnection() {
            if (peerConnection) peerConnection.close();

            peerConnection = new RTCPeerConnection(config);

            // Add Tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.ontrack = (event) => {
                log('Received Remote Track');
                document.getElementById('remoteVideo').srcObject = event.streams[0];
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('candidate', {
                        roomId: roomId,
                        candidate: {
                            candidate: event.candidate.candidate,
                            sdpMid: event.candidate.sdpMid,
                            sdpMLineIndex: event.candidate.sdpMLineIndex
                        }
                    });
                }
            };

            peerConnection.ondatachannel = (event) => {
                log('Received Data Channel (Callee)');
                setupDataChannel(event.channel);
            };

            peerConnection.onconnectionstatechange = () => {
                log('Connection State: ' + peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    log('âœ… WebRTC Connected!');
                }
            };
        }

        function createDataChannel() {
            log('Creating Data Channel (Caller)...');
            dataChannel = peerConnection.createDataChannel("freegram_dc");
            setupDataChannel(dataChannel);
        }

        function setupDataChannel(channel) {
            dataChannel = channel;
            dataChannel.onopen = () => {
                log('âš¡ Data Channel OPEN!');
                startPersonaBehavior();
            };
            dataChannel.onmessage = (event) => {
                log(`ðŸ“¨ Received: ${event.data.substring(0, 50)}...`);
            };
        }

        // --- PERSONA LOGIC ---
        let behaviorInterval;

        function startPersonaBehavior() {
            if (behaviorInterval) clearInterval(behaviorInterval);
            log(`ðŸš€ Starting ${PERSONA} behavior loop...`);

            switch (PERSONA) {
                case 'SPAMMER':
                    // Send message every 100ms
                    behaviorInterval = setInterval(() => {
                        sendMessage('SPAM_SPAM_SPAM_' + Date.now());
                    }, 100);
                    break;

                case 'MALICIOUS':
                    // Send SQLi / XSS payloads
                    {
                        const payloads = [
                            "'; DROP TABLE users; --",
                            "<script>alert(1)<\\/script>",
                            "{{7*7}}", // SSTI
                            "../etc/passwd"
                        ];
                        let i = 0;
                        behaviorInterval = setInterval(() => {
                            sendMessage(payloads[i % payloads.length]);
                            i++;
                        }, 2000);
                    }
                    break;

                case 'FRAGMENTED':
                    // Long string
                    const longStr = "A".repeat(5000);
                    behaviorInterval = setInterval(() => {
                        sendMessage(longStr);
                    }, 3000);
                    break;

                case 'MEDIA':
                    // Fake GIF uploads (Just JSON signals as we don't have real file I/O easily in browser context for now)
                    // Or actually sending binary junk if we wanted to test binary channel
                    behaviorInterval = setInterval(() => {
                        sendJson({ type: 'GIFT', payload: { giftId: 'test_gift', name: 'Bomb' } });
                    }, 5000);
                    break;

                case 'GHOST':
                    // Do nothing, just sit there
                    log('ðŸ‘» Ghosting...');
                    break;

                default:
                    // Normal chat
                    behaviorInterval = setInterval(() => {
                        sendMessage('Hello from ' + botId);
                    }, 5000);
            }
        }

        function sendMessage(text) {
            sendJson({ type: 'CHAT', payload: { text: text } });
        }

        function sendJson(obj) {
            if (dataChannel && dataChannel.readyState === 'open') {
                try {
                    const str = JSON.stringify(obj);
                    dataChannel.send(str);
                    messagesSent++;
                    // log(`Sent: ${str.substring(0, 30)}...`);
                } catch (e) {
                    log('Send Error: ' + e);
                    errors++;
                }
            }
        }

        function closeCall() {
            if (behaviorInterval) clearInterval(behaviorInterval);
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            roomId = null;
            currentPartnerId = null;
        }

        // Start
        start();
    </script>
</body>

</html>